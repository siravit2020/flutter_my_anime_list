// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'anime_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

AnimeModel _$AnimeModelFromJson(Map<String, dynamic> json) {
  return _AnimeModel.fromJson(json);
}

/// @nodoc
mixin _$AnimeModel {
  int? get malId => throw _privateConstructorUsedError;
  String? get url => throw _privateConstructorUsedError;
  Map<AnimeImageType, Image>? get images => throw _privateConstructorUsedError;
  Trailer? get trailer => throw _privateConstructorUsedError;
  bool? get approved => throw _privateConstructorUsedError;
  List<Title>? get titles => throw _privateConstructorUsedError;
  String? get title => throw _privateConstructorUsedError;
  String? get titleEnglish => throw _privateConstructorUsedError;
  String? get titleJapanese => throw _privateConstructorUsedError;
  List<String>? get titleSynonyms => throw _privateConstructorUsedError;
  String? get type => throw _privateConstructorUsedError;
  String? get source => throw _privateConstructorUsedError;
  int? get episodes => throw _privateConstructorUsedError;
  String? get status => throw _privateConstructorUsedError;
  bool? get airing => throw _privateConstructorUsedError;
  Aired? get aired => throw _privateConstructorUsedError;
  String? get duration => throw _privateConstructorUsedError;
  String? get rating => throw _privateConstructorUsedError;
  int? get score => throw _privateConstructorUsedError;
  int? get scoredBy => throw _privateConstructorUsedError;
  int? get rank => throw _privateConstructorUsedError;
  int? get popularity => throw _privateConstructorUsedError;
  int? get members => throw _privateConstructorUsedError;
  int? get favorites => throw _privateConstructorUsedError;
  String? get synopsis => throw _privateConstructorUsedError;
  String? get background => throw _privateConstructorUsedError;
  String? get season => throw _privateConstructorUsedError;
  int? get year => throw _privateConstructorUsedError;
  Broadcast? get broadcast => throw _privateConstructorUsedError;
  List<Demographic>? get producers => throw _privateConstructorUsedError;
  List<Demographic>? get licensors => throw _privateConstructorUsedError;
  List<Demographic>? get studios => throw _privateConstructorUsedError;
  List<Demographic>? get genres => throw _privateConstructorUsedError;
  List<Demographic>? get explicitGenres => throw _privateConstructorUsedError;
  List<Demographic>? get themes => throw _privateConstructorUsedError;
  List<Demographic>? get demographics => throw _privateConstructorUsedError;
  List<Relation>? get relations => throw _privateConstructorUsedError;
  Theme? get theme => throw _privateConstructorUsedError;
  List<External>? get animeModelExternal => throw _privateConstructorUsedError;
  List<External>? get streaming => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AnimeModelCopyWith<AnimeModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnimeModelCopyWith<$Res> {
  factory $AnimeModelCopyWith(
          AnimeModel value, $Res Function(AnimeModel) then) =
      _$AnimeModelCopyWithImpl<$Res, AnimeModel>;
  @useResult
  $Res call(
      {int? malId,
      String? url,
      Map<AnimeImageType, Image>? images,
      Trailer? trailer,
      bool? approved,
      List<Title>? titles,
      String? title,
      String? titleEnglish,
      String? titleJapanese,
      List<String>? titleSynonyms,
      String? type,
      String? source,
      int? episodes,
      String? status,
      bool? airing,
      Aired? aired,
      String? duration,
      String? rating,
      int? score,
      int? scoredBy,
      int? rank,
      int? popularity,
      int? members,
      int? favorites,
      String? synopsis,
      String? background,
      String? season,
      int? year,
      Broadcast? broadcast,
      List<Demographic>? producers,
      List<Demographic>? licensors,
      List<Demographic>? studios,
      List<Demographic>? genres,
      List<Demographic>? explicitGenres,
      List<Demographic>? themes,
      List<Demographic>? demographics,
      List<Relation>? relations,
      Theme? theme,
      List<External>? animeModelExternal,
      List<External>? streaming});

  $TrailerCopyWith<$Res>? get trailer;
  $AiredCopyWith<$Res>? get aired;
  $BroadcastCopyWith<$Res>? get broadcast;
  $ThemeCopyWith<$Res>? get theme;
}

/// @nodoc
class _$AnimeModelCopyWithImpl<$Res, $Val extends AnimeModel>
    implements $AnimeModelCopyWith<$Res> {
  _$AnimeModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? malId = freezed,
    Object? url = freezed,
    Object? images = freezed,
    Object? trailer = freezed,
    Object? approved = freezed,
    Object? titles = freezed,
    Object? title = freezed,
    Object? titleEnglish = freezed,
    Object? titleJapanese = freezed,
    Object? titleSynonyms = freezed,
    Object? type = freezed,
    Object? source = freezed,
    Object? episodes = freezed,
    Object? status = freezed,
    Object? airing = freezed,
    Object? aired = freezed,
    Object? duration = freezed,
    Object? rating = freezed,
    Object? score = freezed,
    Object? scoredBy = freezed,
    Object? rank = freezed,
    Object? popularity = freezed,
    Object? members = freezed,
    Object? favorites = freezed,
    Object? synopsis = freezed,
    Object? background = freezed,
    Object? season = freezed,
    Object? year = freezed,
    Object? broadcast = freezed,
    Object? producers = freezed,
    Object? licensors = freezed,
    Object? studios = freezed,
    Object? genres = freezed,
    Object? explicitGenres = freezed,
    Object? themes = freezed,
    Object? demographics = freezed,
    Object? relations = freezed,
    Object? theme = freezed,
    Object? animeModelExternal = freezed,
    Object? streaming = freezed,
  }) {
    return _then(_value.copyWith(
      malId: freezed == malId
          ? _value.malId
          : malId // ignore: cast_nullable_to_non_nullable
              as int?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      images: freezed == images
          ? _value.images
          : images // ignore: cast_nullable_to_non_nullable
              as Map<AnimeImageType, Image>?,
      trailer: freezed == trailer
          ? _value.trailer
          : trailer // ignore: cast_nullable_to_non_nullable
              as Trailer?,
      approved: freezed == approved
          ? _value.approved
          : approved // ignore: cast_nullable_to_non_nullable
              as bool?,
      titles: freezed == titles
          ? _value.titles
          : titles // ignore: cast_nullable_to_non_nullable
              as List<Title>?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      titleEnglish: freezed == titleEnglish
          ? _value.titleEnglish
          : titleEnglish // ignore: cast_nullable_to_non_nullable
              as String?,
      titleJapanese: freezed == titleJapanese
          ? _value.titleJapanese
          : titleJapanese // ignore: cast_nullable_to_non_nullable
              as String?,
      titleSynonyms: freezed == titleSynonyms
          ? _value.titleSynonyms
          : titleSynonyms // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String?,
      episodes: freezed == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as int?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      airing: freezed == airing
          ? _value.airing
          : airing // ignore: cast_nullable_to_non_nullable
              as bool?,
      aired: freezed == aired
          ? _value.aired
          : aired // ignore: cast_nullable_to_non_nullable
              as Aired?,
      duration: freezed == duration
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as String?,
      rating: freezed == rating
          ? _value.rating
          : rating // ignore: cast_nullable_to_non_nullable
              as String?,
      score: freezed == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as int?,
      scoredBy: freezed == scoredBy
          ? _value.scoredBy
          : scoredBy // ignore: cast_nullable_to_non_nullable
              as int?,
      rank: freezed == rank
          ? _value.rank
          : rank // ignore: cast_nullable_to_non_nullable
              as int?,
      popularity: freezed == popularity
          ? _value.popularity
          : popularity // ignore: cast_nullable_to_non_nullable
              as int?,
      members: freezed == members
          ? _value.members
          : members // ignore: cast_nullable_to_non_nullable
              as int?,
      favorites: freezed == favorites
          ? _value.favorites
          : favorites // ignore: cast_nullable_to_non_nullable
              as int?,
      synopsis: freezed == synopsis
          ? _value.synopsis
          : synopsis // ignore: cast_nullable_to_non_nullable
              as String?,
      background: freezed == background
          ? _value.background
          : background // ignore: cast_nullable_to_non_nullable
              as String?,
      season: freezed == season
          ? _value.season
          : season // ignore: cast_nullable_to_non_nullable
              as String?,
      year: freezed == year
          ? _value.year
          : year // ignore: cast_nullable_to_non_nullable
              as int?,
      broadcast: freezed == broadcast
          ? _value.broadcast
          : broadcast // ignore: cast_nullable_to_non_nullable
              as Broadcast?,
      producers: freezed == producers
          ? _value.producers
          : producers // ignore: cast_nullable_to_non_nullable
              as List<Demographic>?,
      licensors: freezed == licensors
          ? _value.licensors
          : licensors // ignore: cast_nullable_to_non_nullable
              as List<Demographic>?,
      studios: freezed == studios
          ? _value.studios
          : studios // ignore: cast_nullable_to_non_nullable
              as List<Demographic>?,
      genres: freezed == genres
          ? _value.genres
          : genres // ignore: cast_nullable_to_non_nullable
              as List<Demographic>?,
      explicitGenres: freezed == explicitGenres
          ? _value.explicitGenres
          : explicitGenres // ignore: cast_nullable_to_non_nullable
              as List<Demographic>?,
      themes: freezed == themes
          ? _value.themes
          : themes // ignore: cast_nullable_to_non_nullable
              as List<Demographic>?,
      demographics: freezed == demographics
          ? _value.demographics
          : demographics // ignore: cast_nullable_to_non_nullable
              as List<Demographic>?,
      relations: freezed == relations
          ? _value.relations
          : relations // ignore: cast_nullable_to_non_nullable
              as List<Relation>?,
      theme: freezed == theme
          ? _value.theme
          : theme // ignore: cast_nullable_to_non_nullable
              as Theme?,
      animeModelExternal: freezed == animeModelExternal
          ? _value.animeModelExternal
          : animeModelExternal // ignore: cast_nullable_to_non_nullable
              as List<External>?,
      streaming: freezed == streaming
          ? _value.streaming
          : streaming // ignore: cast_nullable_to_non_nullable
              as List<External>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $TrailerCopyWith<$Res>? get trailer {
    if (_value.trailer == null) {
      return null;
    }

    return $TrailerCopyWith<$Res>(_value.trailer!, (value) {
      return _then(_value.copyWith(trailer: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AiredCopyWith<$Res>? get aired {
    if (_value.aired == null) {
      return null;
    }

    return $AiredCopyWith<$Res>(_value.aired!, (value) {
      return _then(_value.copyWith(aired: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $BroadcastCopyWith<$Res>? get broadcast {
    if (_value.broadcast == null) {
      return null;
    }

    return $BroadcastCopyWith<$Res>(_value.broadcast!, (value) {
      return _then(_value.copyWith(broadcast: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ThemeCopyWith<$Res>? get theme {
    if (_value.theme == null) {
      return null;
    }

    return $ThemeCopyWith<$Res>(_value.theme!, (value) {
      return _then(_value.copyWith(theme: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AnimeModelImplCopyWith<$Res>
    implements $AnimeModelCopyWith<$Res> {
  factory _$$AnimeModelImplCopyWith(
          _$AnimeModelImpl value, $Res Function(_$AnimeModelImpl) then) =
      __$$AnimeModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? malId,
      String? url,
      Map<AnimeImageType, Image>? images,
      Trailer? trailer,
      bool? approved,
      List<Title>? titles,
      String? title,
      String? titleEnglish,
      String? titleJapanese,
      List<String>? titleSynonyms,
      String? type,
      String? source,
      int? episodes,
      String? status,
      bool? airing,
      Aired? aired,
      String? duration,
      String? rating,
      int? score,
      int? scoredBy,
      int? rank,
      int? popularity,
      int? members,
      int? favorites,
      String? synopsis,
      String? background,
      String? season,
      int? year,
      Broadcast? broadcast,
      List<Demographic>? producers,
      List<Demographic>? licensors,
      List<Demographic>? studios,
      List<Demographic>? genres,
      List<Demographic>? explicitGenres,
      List<Demographic>? themes,
      List<Demographic>? demographics,
      List<Relation>? relations,
      Theme? theme,
      List<External>? animeModelExternal,
      List<External>? streaming});

  @override
  $TrailerCopyWith<$Res>? get trailer;
  @override
  $AiredCopyWith<$Res>? get aired;
  @override
  $BroadcastCopyWith<$Res>? get broadcast;
  @override
  $ThemeCopyWith<$Res>? get theme;
}

/// @nodoc
class __$$AnimeModelImplCopyWithImpl<$Res>
    extends _$AnimeModelCopyWithImpl<$Res, _$AnimeModelImpl>
    implements _$$AnimeModelImplCopyWith<$Res> {
  __$$AnimeModelImplCopyWithImpl(
      _$AnimeModelImpl _value, $Res Function(_$AnimeModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? malId = freezed,
    Object? url = freezed,
    Object? images = freezed,
    Object? trailer = freezed,
    Object? approved = freezed,
    Object? titles = freezed,
    Object? title = freezed,
    Object? titleEnglish = freezed,
    Object? titleJapanese = freezed,
    Object? titleSynonyms = freezed,
    Object? type = freezed,
    Object? source = freezed,
    Object? episodes = freezed,
    Object? status = freezed,
    Object? airing = freezed,
    Object? aired = freezed,
    Object? duration = freezed,
    Object? rating = freezed,
    Object? score = freezed,
    Object? scoredBy = freezed,
    Object? rank = freezed,
    Object? popularity = freezed,
    Object? members = freezed,
    Object? favorites = freezed,
    Object? synopsis = freezed,
    Object? background = freezed,
    Object? season = freezed,
    Object? year = freezed,
    Object? broadcast = freezed,
    Object? producers = freezed,
    Object? licensors = freezed,
    Object? studios = freezed,
    Object? genres = freezed,
    Object? explicitGenres = freezed,
    Object? themes = freezed,
    Object? demographics = freezed,
    Object? relations = freezed,
    Object? theme = freezed,
    Object? animeModelExternal = freezed,
    Object? streaming = freezed,
  }) {
    return _then(_$AnimeModelImpl(
      malId: freezed == malId
          ? _value.malId
          : malId // ignore: cast_nullable_to_non_nullable
              as int?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      images: freezed == images
          ? _value._images
          : images // ignore: cast_nullable_to_non_nullable
              as Map<AnimeImageType, Image>?,
      trailer: freezed == trailer
          ? _value.trailer
          : trailer // ignore: cast_nullable_to_non_nullable
              as Trailer?,
      approved: freezed == approved
          ? _value.approved
          : approved // ignore: cast_nullable_to_non_nullable
              as bool?,
      titles: freezed == titles
          ? _value._titles
          : titles // ignore: cast_nullable_to_non_nullable
              as List<Title>?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      titleEnglish: freezed == titleEnglish
          ? _value.titleEnglish
          : titleEnglish // ignore: cast_nullable_to_non_nullable
              as String?,
      titleJapanese: freezed == titleJapanese
          ? _value.titleJapanese
          : titleJapanese // ignore: cast_nullable_to_non_nullable
              as String?,
      titleSynonyms: freezed == titleSynonyms
          ? _value._titleSynonyms
          : titleSynonyms // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String?,
      episodes: freezed == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as int?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      airing: freezed == airing
          ? _value.airing
          : airing // ignore: cast_nullable_to_non_nullable
              as bool?,
      aired: freezed == aired
          ? _value.aired
          : aired // ignore: cast_nullable_to_non_nullable
              as Aired?,
      duration: freezed == duration
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as String?,
      rating: freezed == rating
          ? _value.rating
          : rating // ignore: cast_nullable_to_non_nullable
              as String?,
      score: freezed == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as int?,
      scoredBy: freezed == scoredBy
          ? _value.scoredBy
          : scoredBy // ignore: cast_nullable_to_non_nullable
              as int?,
      rank: freezed == rank
          ? _value.rank
          : rank // ignore: cast_nullable_to_non_nullable
              as int?,
      popularity: freezed == popularity
          ? _value.popularity
          : popularity // ignore: cast_nullable_to_non_nullable
              as int?,
      members: freezed == members
          ? _value.members
          : members // ignore: cast_nullable_to_non_nullable
              as int?,
      favorites: freezed == favorites
          ? _value.favorites
          : favorites // ignore: cast_nullable_to_non_nullable
              as int?,
      synopsis: freezed == synopsis
          ? _value.synopsis
          : synopsis // ignore: cast_nullable_to_non_nullable
              as String?,
      background: freezed == background
          ? _value.background
          : background // ignore: cast_nullable_to_non_nullable
              as String?,
      season: freezed == season
          ? _value.season
          : season // ignore: cast_nullable_to_non_nullable
              as String?,
      year: freezed == year
          ? _value.year
          : year // ignore: cast_nullable_to_non_nullable
              as int?,
      broadcast: freezed == broadcast
          ? _value.broadcast
          : broadcast // ignore: cast_nullable_to_non_nullable
              as Broadcast?,
      producers: freezed == producers
          ? _value._producers
          : producers // ignore: cast_nullable_to_non_nullable
              as List<Demographic>?,
      licensors: freezed == licensors
          ? _value._licensors
          : licensors // ignore: cast_nullable_to_non_nullable
              as List<Demographic>?,
      studios: freezed == studios
          ? _value._studios
          : studios // ignore: cast_nullable_to_non_nullable
              as List<Demographic>?,
      genres: freezed == genres
          ? _value._genres
          : genres // ignore: cast_nullable_to_non_nullable
              as List<Demographic>?,
      explicitGenres: freezed == explicitGenres
          ? _value._explicitGenres
          : explicitGenres // ignore: cast_nullable_to_non_nullable
              as List<Demographic>?,
      themes: freezed == themes
          ? _value._themes
          : themes // ignore: cast_nullable_to_non_nullable
              as List<Demographic>?,
      demographics: freezed == demographics
          ? _value._demographics
          : demographics // ignore: cast_nullable_to_non_nullable
              as List<Demographic>?,
      relations: freezed == relations
          ? _value._relations
          : relations // ignore: cast_nullable_to_non_nullable
              as List<Relation>?,
      theme: freezed == theme
          ? _value.theme
          : theme // ignore: cast_nullable_to_non_nullable
              as Theme?,
      animeModelExternal: freezed == animeModelExternal
          ? _value._animeModelExternal
          : animeModelExternal // ignore: cast_nullable_to_non_nullable
              as List<External>?,
      streaming: freezed == streaming
          ? _value._streaming
          : streaming // ignore: cast_nullable_to_non_nullable
              as List<External>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AnimeModelImpl implements _AnimeModel {
  const _$AnimeModelImpl(
      {this.malId,
      this.url,
      final Map<AnimeImageType, Image>? images,
      this.trailer,
      this.approved,
      final List<Title>? titles,
      this.title,
      this.titleEnglish,
      this.titleJapanese,
      final List<String>? titleSynonyms,
      this.type,
      this.source,
      this.episodes,
      this.status,
      this.airing,
      this.aired,
      this.duration,
      this.rating,
      this.score,
      this.scoredBy,
      this.rank,
      this.popularity,
      this.members,
      this.favorites,
      this.synopsis,
      this.background,
      this.season,
      this.year,
      this.broadcast,
      final List<Demographic>? producers,
      final List<Demographic>? licensors,
      final List<Demographic>? studios,
      final List<Demographic>? genres,
      final List<Demographic>? explicitGenres,
      final List<Demographic>? themes,
      final List<Demographic>? demographics,
      final List<Relation>? relations,
      this.theme,
      final List<External>? animeModelExternal,
      final List<External>? streaming})
      : _images = images,
        _titles = titles,
        _titleSynonyms = titleSynonyms,
        _producers = producers,
        _licensors = licensors,
        _studios = studios,
        _genres = genres,
        _explicitGenres = explicitGenres,
        _themes = themes,
        _demographics = demographics,
        _relations = relations,
        _animeModelExternal = animeModelExternal,
        _streaming = streaming;

  factory _$AnimeModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$AnimeModelImplFromJson(json);

  @override
  final int? malId;
  @override
  final String? url;
  final Map<AnimeImageType, Image>? _images;
  @override
  Map<AnimeImageType, Image>? get images {
    final value = _images;
    if (value == null) return null;
    if (_images is EqualUnmodifiableMapView) return _images;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final Trailer? trailer;
  @override
  final bool? approved;
  final List<Title>? _titles;
  @override
  List<Title>? get titles {
    final value = _titles;
    if (value == null) return null;
    if (_titles is EqualUnmodifiableListView) return _titles;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? title;
  @override
  final String? titleEnglish;
  @override
  final String? titleJapanese;
  final List<String>? _titleSynonyms;
  @override
  List<String>? get titleSynonyms {
    final value = _titleSynonyms;
    if (value == null) return null;
    if (_titleSynonyms is EqualUnmodifiableListView) return _titleSynonyms;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? type;
  @override
  final String? source;
  @override
  final int? episodes;
  @override
  final String? status;
  @override
  final bool? airing;
  @override
  final Aired? aired;
  @override
  final String? duration;
  @override
  final String? rating;
  @override
  final int? score;
  @override
  final int? scoredBy;
  @override
  final int? rank;
  @override
  final int? popularity;
  @override
  final int? members;
  @override
  final int? favorites;
  @override
  final String? synopsis;
  @override
  final String? background;
  @override
  final String? season;
  @override
  final int? year;
  @override
  final Broadcast? broadcast;
  final List<Demographic>? _producers;
  @override
  List<Demographic>? get producers {
    final value = _producers;
    if (value == null) return null;
    if (_producers is EqualUnmodifiableListView) return _producers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Demographic>? _licensors;
  @override
  List<Demographic>? get licensors {
    final value = _licensors;
    if (value == null) return null;
    if (_licensors is EqualUnmodifiableListView) return _licensors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Demographic>? _studios;
  @override
  List<Demographic>? get studios {
    final value = _studios;
    if (value == null) return null;
    if (_studios is EqualUnmodifiableListView) return _studios;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Demographic>? _genres;
  @override
  List<Demographic>? get genres {
    final value = _genres;
    if (value == null) return null;
    if (_genres is EqualUnmodifiableListView) return _genres;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Demographic>? _explicitGenres;
  @override
  List<Demographic>? get explicitGenres {
    final value = _explicitGenres;
    if (value == null) return null;
    if (_explicitGenres is EqualUnmodifiableListView) return _explicitGenres;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Demographic>? _themes;
  @override
  List<Demographic>? get themes {
    final value = _themes;
    if (value == null) return null;
    if (_themes is EqualUnmodifiableListView) return _themes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Demographic>? _demographics;
  @override
  List<Demographic>? get demographics {
    final value = _demographics;
    if (value == null) return null;
    if (_demographics is EqualUnmodifiableListView) return _demographics;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Relation>? _relations;
  @override
  List<Relation>? get relations {
    final value = _relations;
    if (value == null) return null;
    if (_relations is EqualUnmodifiableListView) return _relations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final Theme? theme;
  final List<External>? _animeModelExternal;
  @override
  List<External>? get animeModelExternal {
    final value = _animeModelExternal;
    if (value == null) return null;
    if (_animeModelExternal is EqualUnmodifiableListView)
      return _animeModelExternal;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<External>? _streaming;
  @override
  List<External>? get streaming {
    final value = _streaming;
    if (value == null) return null;
    if (_streaming is EqualUnmodifiableListView) return _streaming;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'AnimeModel(malId: $malId, url: $url, images: $images, trailer: $trailer, approved: $approved, titles: $titles, title: $title, titleEnglish: $titleEnglish, titleJapanese: $titleJapanese, titleSynonyms: $titleSynonyms, type: $type, source: $source, episodes: $episodes, status: $status, airing: $airing, aired: $aired, duration: $duration, rating: $rating, score: $score, scoredBy: $scoredBy, rank: $rank, popularity: $popularity, members: $members, favorites: $favorites, synopsis: $synopsis, background: $background, season: $season, year: $year, broadcast: $broadcast, producers: $producers, licensors: $licensors, studios: $studios, genres: $genres, explicitGenres: $explicitGenres, themes: $themes, demographics: $demographics, relations: $relations, theme: $theme, animeModelExternal: $animeModelExternal, streaming: $streaming)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnimeModelImpl &&
            (identical(other.malId, malId) || other.malId == malId) &&
            (identical(other.url, url) || other.url == url) &&
            const DeepCollectionEquality().equals(other._images, _images) &&
            (identical(other.trailer, trailer) || other.trailer == trailer) &&
            (identical(other.approved, approved) ||
                other.approved == approved) &&
            const DeepCollectionEquality().equals(other._titles, _titles) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.titleEnglish, titleEnglish) ||
                other.titleEnglish == titleEnglish) &&
            (identical(other.titleJapanese, titleJapanese) ||
                other.titleJapanese == titleJapanese) &&
            const DeepCollectionEquality()
                .equals(other._titleSynonyms, _titleSynonyms) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.source, source) || other.source == source) &&
            (identical(other.episodes, episodes) ||
                other.episodes == episodes) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.airing, airing) || other.airing == airing) &&
            (identical(other.aired, aired) || other.aired == aired) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.rating, rating) || other.rating == rating) &&
            (identical(other.score, score) || other.score == score) &&
            (identical(other.scoredBy, scoredBy) ||
                other.scoredBy == scoredBy) &&
            (identical(other.rank, rank) || other.rank == rank) &&
            (identical(other.popularity, popularity) ||
                other.popularity == popularity) &&
            (identical(other.members, members) || other.members == members) &&
            (identical(other.favorites, favorites) ||
                other.favorites == favorites) &&
            (identical(other.synopsis, synopsis) ||
                other.synopsis == synopsis) &&
            (identical(other.background, background) ||
                other.background == background) &&
            (identical(other.season, season) || other.season == season) &&
            (identical(other.year, year) || other.year == year) &&
            (identical(other.broadcast, broadcast) ||
                other.broadcast == broadcast) &&
            const DeepCollectionEquality()
                .equals(other._producers, _producers) &&
            const DeepCollectionEquality()
                .equals(other._licensors, _licensors) &&
            const DeepCollectionEquality().equals(other._studios, _studios) &&
            const DeepCollectionEquality().equals(other._genres, _genres) &&
            const DeepCollectionEquality()
                .equals(other._explicitGenres, _explicitGenres) &&
            const DeepCollectionEquality().equals(other._themes, _themes) &&
            const DeepCollectionEquality()
                .equals(other._demographics, _demographics) &&
            const DeepCollectionEquality()
                .equals(other._relations, _relations) &&
            (identical(other.theme, theme) || other.theme == theme) &&
            const DeepCollectionEquality()
                .equals(other._animeModelExternal, _animeModelExternal) &&
            const DeepCollectionEquality()
                .equals(other._streaming, _streaming));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        malId,
        url,
        const DeepCollectionEquality().hash(_images),
        trailer,
        approved,
        const DeepCollectionEquality().hash(_titles),
        title,
        titleEnglish,
        titleJapanese,
        const DeepCollectionEquality().hash(_titleSynonyms),
        type,
        source,
        episodes,
        status,
        airing,
        aired,
        duration,
        rating,
        score,
        scoredBy,
        rank,
        popularity,
        members,
        favorites,
        synopsis,
        background,
        season,
        year,
        broadcast,
        const DeepCollectionEquality().hash(_producers),
        const DeepCollectionEquality().hash(_licensors),
        const DeepCollectionEquality().hash(_studios),
        const DeepCollectionEquality().hash(_genres),
        const DeepCollectionEquality().hash(_explicitGenres),
        const DeepCollectionEquality().hash(_themes),
        const DeepCollectionEquality().hash(_demographics),
        const DeepCollectionEquality().hash(_relations),
        theme,
        const DeepCollectionEquality().hash(_animeModelExternal),
        const DeepCollectionEquality().hash(_streaming)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnimeModelImplCopyWith<_$AnimeModelImpl> get copyWith =>
      __$$AnimeModelImplCopyWithImpl<_$AnimeModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AnimeModelImplToJson(
      this,
    );
  }
}

abstract class _AnimeModel implements AnimeModel {
  const factory _AnimeModel(
      {final int? malId,
      final String? url,
      final Map<AnimeImageType, Image>? images,
      final Trailer? trailer,
      final bool? approved,
      final List<Title>? titles,
      final String? title,
      final String? titleEnglish,
      final String? titleJapanese,
      final List<String>? titleSynonyms,
      final String? type,
      final String? source,
      final int? episodes,
      final String? status,
      final bool? airing,
      final Aired? aired,
      final String? duration,
      final String? rating,
      final int? score,
      final int? scoredBy,
      final int? rank,
      final int? popularity,
      final int? members,
      final int? favorites,
      final String? synopsis,
      final String? background,
      final String? season,
      final int? year,
      final Broadcast? broadcast,
      final List<Demographic>? producers,
      final List<Demographic>? licensors,
      final List<Demographic>? studios,
      final List<Demographic>? genres,
      final List<Demographic>? explicitGenres,
      final List<Demographic>? themes,
      final List<Demographic>? demographics,
      final List<Relation>? relations,
      final Theme? theme,
      final List<External>? animeModelExternal,
      final List<External>? streaming}) = _$AnimeModelImpl;

  factory _AnimeModel.fromJson(Map<String, dynamic> json) =
      _$AnimeModelImpl.fromJson;

  @override
  int? get malId;
  @override
  String? get url;
  @override
  Map<AnimeImageType, Image>? get images;
  @override
  Trailer? get trailer;
  @override
  bool? get approved;
  @override
  List<Title>? get titles;
  @override
  String? get title;
  @override
  String? get titleEnglish;
  @override
  String? get titleJapanese;
  @override
  List<String>? get titleSynonyms;
  @override
  String? get type;
  @override
  String? get source;
  @override
  int? get episodes;
  @override
  String? get status;
  @override
  bool? get airing;
  @override
  Aired? get aired;
  @override
  String? get duration;
  @override
  String? get rating;
  @override
  int? get score;
  @override
  int? get scoredBy;
  @override
  int? get rank;
  @override
  int? get popularity;
  @override
  int? get members;
  @override
  int? get favorites;
  @override
  String? get synopsis;
  @override
  String? get background;
  @override
  String? get season;
  @override
  int? get year;
  @override
  Broadcast? get broadcast;
  @override
  List<Demographic>? get producers;
  @override
  List<Demographic>? get licensors;
  @override
  List<Demographic>? get studios;
  @override
  List<Demographic>? get genres;
  @override
  List<Demographic>? get explicitGenres;
  @override
  List<Demographic>? get themes;
  @override
  List<Demographic>? get demographics;
  @override
  List<Relation>? get relations;
  @override
  Theme? get theme;
  @override
  List<External>? get animeModelExternal;
  @override
  List<External>? get streaming;
  @override
  @JsonKey(ignore: true)
  _$$AnimeModelImplCopyWith<_$AnimeModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Aired _$AiredFromJson(Map<String, dynamic> json) {
  return _Aired.fromJson(json);
}

/// @nodoc
mixin _$Aired {
  String? get from => throw _privateConstructorUsedError;
  String? get to => throw _privateConstructorUsedError;
  Prop? get prop => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AiredCopyWith<Aired> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AiredCopyWith<$Res> {
  factory $AiredCopyWith(Aired value, $Res Function(Aired) then) =
      _$AiredCopyWithImpl<$Res, Aired>;
  @useResult
  $Res call({String? from, String? to, Prop? prop});

  $PropCopyWith<$Res>? get prop;
}

/// @nodoc
class _$AiredCopyWithImpl<$Res, $Val extends Aired>
    implements $AiredCopyWith<$Res> {
  _$AiredCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? from = freezed,
    Object? to = freezed,
    Object? prop = freezed,
  }) {
    return _then(_value.copyWith(
      from: freezed == from
          ? _value.from
          : from // ignore: cast_nullable_to_non_nullable
              as String?,
      to: freezed == to
          ? _value.to
          : to // ignore: cast_nullable_to_non_nullable
              as String?,
      prop: freezed == prop
          ? _value.prop
          : prop // ignore: cast_nullable_to_non_nullable
              as Prop?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $PropCopyWith<$Res>? get prop {
    if (_value.prop == null) {
      return null;
    }

    return $PropCopyWith<$Res>(_value.prop!, (value) {
      return _then(_value.copyWith(prop: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AiredImplCopyWith<$Res> implements $AiredCopyWith<$Res> {
  factory _$$AiredImplCopyWith(
          _$AiredImpl value, $Res Function(_$AiredImpl) then) =
      __$$AiredImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? from, String? to, Prop? prop});

  @override
  $PropCopyWith<$Res>? get prop;
}

/// @nodoc
class __$$AiredImplCopyWithImpl<$Res>
    extends _$AiredCopyWithImpl<$Res, _$AiredImpl>
    implements _$$AiredImplCopyWith<$Res> {
  __$$AiredImplCopyWithImpl(
      _$AiredImpl _value, $Res Function(_$AiredImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? from = freezed,
    Object? to = freezed,
    Object? prop = freezed,
  }) {
    return _then(_$AiredImpl(
      from: freezed == from
          ? _value.from
          : from // ignore: cast_nullable_to_non_nullable
              as String?,
      to: freezed == to
          ? _value.to
          : to // ignore: cast_nullable_to_non_nullable
              as String?,
      prop: freezed == prop
          ? _value.prop
          : prop // ignore: cast_nullable_to_non_nullable
              as Prop?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AiredImpl implements _Aired {
  const _$AiredImpl({this.from, this.to, this.prop});

  factory _$AiredImpl.fromJson(Map<String, dynamic> json) =>
      _$$AiredImplFromJson(json);

  @override
  final String? from;
  @override
  final String? to;
  @override
  final Prop? prop;

  @override
  String toString() {
    return 'Aired(from: $from, to: $to, prop: $prop)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AiredImpl &&
            (identical(other.from, from) || other.from == from) &&
            (identical(other.to, to) || other.to == to) &&
            (identical(other.prop, prop) || other.prop == prop));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, from, to, prop);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AiredImplCopyWith<_$AiredImpl> get copyWith =>
      __$$AiredImplCopyWithImpl<_$AiredImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AiredImplToJson(
      this,
    );
  }
}

abstract class _Aired implements Aired {
  const factory _Aired(
      {final String? from, final String? to, final Prop? prop}) = _$AiredImpl;

  factory _Aired.fromJson(Map<String, dynamic> json) = _$AiredImpl.fromJson;

  @override
  String? get from;
  @override
  String? get to;
  @override
  Prop? get prop;
  @override
  @JsonKey(ignore: true)
  _$$AiredImplCopyWith<_$AiredImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Prop _$PropFromJson(Map<String, dynamic> json) {
  return _Prop.fromJson(json);
}

/// @nodoc
mixin _$Prop {
  From? get from => throw _privateConstructorUsedError;
  From? get to => throw _privateConstructorUsedError;
  String? get string => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PropCopyWith<Prop> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PropCopyWith<$Res> {
  factory $PropCopyWith(Prop value, $Res Function(Prop) then) =
      _$PropCopyWithImpl<$Res, Prop>;
  @useResult
  $Res call({From? from, From? to, String? string});

  $FromCopyWith<$Res>? get from;
  $FromCopyWith<$Res>? get to;
}

/// @nodoc
class _$PropCopyWithImpl<$Res, $Val extends Prop>
    implements $PropCopyWith<$Res> {
  _$PropCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? from = freezed,
    Object? to = freezed,
    Object? string = freezed,
  }) {
    return _then(_value.copyWith(
      from: freezed == from
          ? _value.from
          : from // ignore: cast_nullable_to_non_nullable
              as From?,
      to: freezed == to
          ? _value.to
          : to // ignore: cast_nullable_to_non_nullable
              as From?,
      string: freezed == string
          ? _value.string
          : string // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FromCopyWith<$Res>? get from {
    if (_value.from == null) {
      return null;
    }

    return $FromCopyWith<$Res>(_value.from!, (value) {
      return _then(_value.copyWith(from: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FromCopyWith<$Res>? get to {
    if (_value.to == null) {
      return null;
    }

    return $FromCopyWith<$Res>(_value.to!, (value) {
      return _then(_value.copyWith(to: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$PropImplCopyWith<$Res> implements $PropCopyWith<$Res> {
  factory _$$PropImplCopyWith(
          _$PropImpl value, $Res Function(_$PropImpl) then) =
      __$$PropImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({From? from, From? to, String? string});

  @override
  $FromCopyWith<$Res>? get from;
  @override
  $FromCopyWith<$Res>? get to;
}

/// @nodoc
class __$$PropImplCopyWithImpl<$Res>
    extends _$PropCopyWithImpl<$Res, _$PropImpl>
    implements _$$PropImplCopyWith<$Res> {
  __$$PropImplCopyWithImpl(_$PropImpl _value, $Res Function(_$PropImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? from = freezed,
    Object? to = freezed,
    Object? string = freezed,
  }) {
    return _then(_$PropImpl(
      from: freezed == from
          ? _value.from
          : from // ignore: cast_nullable_to_non_nullable
              as From?,
      to: freezed == to
          ? _value.to
          : to // ignore: cast_nullable_to_non_nullable
              as From?,
      string: freezed == string
          ? _value.string
          : string // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PropImpl implements _Prop {
  const _$PropImpl({this.from, this.to, this.string});

  factory _$PropImpl.fromJson(Map<String, dynamic> json) =>
      _$$PropImplFromJson(json);

  @override
  final From? from;
  @override
  final From? to;
  @override
  final String? string;

  @override
  String toString() {
    return 'Prop(from: $from, to: $to, string: $string)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PropImpl &&
            (identical(other.from, from) || other.from == from) &&
            (identical(other.to, to) || other.to == to) &&
            (identical(other.string, string) || other.string == string));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, from, to, string);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PropImplCopyWith<_$PropImpl> get copyWith =>
      __$$PropImplCopyWithImpl<_$PropImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PropImplToJson(
      this,
    );
  }
}

abstract class _Prop implements Prop {
  const factory _Prop(
      {final From? from, final From? to, final String? string}) = _$PropImpl;

  factory _Prop.fromJson(Map<String, dynamic> json) = _$PropImpl.fromJson;

  @override
  From? get from;
  @override
  From? get to;
  @override
  String? get string;
  @override
  @JsonKey(ignore: true)
  _$$PropImplCopyWith<_$PropImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

From _$FromFromJson(Map<String, dynamic> json) {
  return _From.fromJson(json);
}

/// @nodoc
mixin _$From {
  int? get day => throw _privateConstructorUsedError;
  int? get month => throw _privateConstructorUsedError;
  int? get year => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FromCopyWith<From> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FromCopyWith<$Res> {
  factory $FromCopyWith(From value, $Res Function(From) then) =
      _$FromCopyWithImpl<$Res, From>;
  @useResult
  $Res call({int? day, int? month, int? year});
}

/// @nodoc
class _$FromCopyWithImpl<$Res, $Val extends From>
    implements $FromCopyWith<$Res> {
  _$FromCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? day = freezed,
    Object? month = freezed,
    Object? year = freezed,
  }) {
    return _then(_value.copyWith(
      day: freezed == day
          ? _value.day
          : day // ignore: cast_nullable_to_non_nullable
              as int?,
      month: freezed == month
          ? _value.month
          : month // ignore: cast_nullable_to_non_nullable
              as int?,
      year: freezed == year
          ? _value.year
          : year // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FromImplCopyWith<$Res> implements $FromCopyWith<$Res> {
  factory _$$FromImplCopyWith(
          _$FromImpl value, $Res Function(_$FromImpl) then) =
      __$$FromImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? day, int? month, int? year});
}

/// @nodoc
class __$$FromImplCopyWithImpl<$Res>
    extends _$FromCopyWithImpl<$Res, _$FromImpl>
    implements _$$FromImplCopyWith<$Res> {
  __$$FromImplCopyWithImpl(_$FromImpl _value, $Res Function(_$FromImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? day = freezed,
    Object? month = freezed,
    Object? year = freezed,
  }) {
    return _then(_$FromImpl(
      day: freezed == day
          ? _value.day
          : day // ignore: cast_nullable_to_non_nullable
              as int?,
      month: freezed == month
          ? _value.month
          : month // ignore: cast_nullable_to_non_nullable
              as int?,
      year: freezed == year
          ? _value.year
          : year // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FromImpl implements _From {
  const _$FromImpl({this.day, this.month, this.year});

  factory _$FromImpl.fromJson(Map<String, dynamic> json) =>
      _$$FromImplFromJson(json);

  @override
  final int? day;
  @override
  final int? month;
  @override
  final int? year;

  @override
  String toString() {
    return 'From(day: $day, month: $month, year: $year)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FromImpl &&
            (identical(other.day, day) || other.day == day) &&
            (identical(other.month, month) || other.month == month) &&
            (identical(other.year, year) || other.year == year));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, day, month, year);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FromImplCopyWith<_$FromImpl> get copyWith =>
      __$$FromImplCopyWithImpl<_$FromImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FromImplToJson(
      this,
    );
  }
}

abstract class _From implements From {
  const factory _From({final int? day, final int? month, final int? year}) =
      _$FromImpl;

  factory _From.fromJson(Map<String, dynamic> json) = _$FromImpl.fromJson;

  @override
  int? get day;
  @override
  int? get month;
  @override
  int? get year;
  @override
  @JsonKey(ignore: true)
  _$$FromImplCopyWith<_$FromImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

External _$ExternalFromJson(Map<String, dynamic> json) {
  return _External.fromJson(json);
}

/// @nodoc
mixin _$External {
  String? get name => throw _privateConstructorUsedError;
  String? get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExternalCopyWith<External> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExternalCopyWith<$Res> {
  factory $ExternalCopyWith(External value, $Res Function(External) then) =
      _$ExternalCopyWithImpl<$Res, External>;
  @useResult
  $Res call({String? name, String? url});
}

/// @nodoc
class _$ExternalCopyWithImpl<$Res, $Val extends External>
    implements $ExternalCopyWith<$Res> {
  _$ExternalCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? url = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ExternalImplCopyWith<$Res>
    implements $ExternalCopyWith<$Res> {
  factory _$$ExternalImplCopyWith(
          _$ExternalImpl value, $Res Function(_$ExternalImpl) then) =
      __$$ExternalImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? name, String? url});
}

/// @nodoc
class __$$ExternalImplCopyWithImpl<$Res>
    extends _$ExternalCopyWithImpl<$Res, _$ExternalImpl>
    implements _$$ExternalImplCopyWith<$Res> {
  __$$ExternalImplCopyWithImpl(
      _$ExternalImpl _value, $Res Function(_$ExternalImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? url = freezed,
  }) {
    return _then(_$ExternalImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExternalImpl implements _External {
  const _$ExternalImpl({this.name, this.url});

  factory _$ExternalImpl.fromJson(Map<String, dynamic> json) =>
      _$$ExternalImplFromJson(json);

  @override
  final String? name;
  @override
  final String? url;

  @override
  String toString() {
    return 'External(name: $name, url: $url)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExternalImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExternalImplCopyWith<_$ExternalImpl> get copyWith =>
      __$$ExternalImplCopyWithImpl<_$ExternalImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExternalImplToJson(
      this,
    );
  }
}

abstract class _External implements External {
  const factory _External({final String? name, final String? url}) =
      _$ExternalImpl;

  factory _External.fromJson(Map<String, dynamic> json) =
      _$ExternalImpl.fromJson;

  @override
  String? get name;
  @override
  String? get url;
  @override
  @JsonKey(ignore: true)
  _$$ExternalImplCopyWith<_$ExternalImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Broadcast _$BroadcastFromJson(Map<String, dynamic> json) {
  return _Broadcast.fromJson(json);
}

/// @nodoc
mixin _$Broadcast {
  String? get day => throw _privateConstructorUsedError;
  String? get time => throw _privateConstructorUsedError;
  String? get timezone => throw _privateConstructorUsedError;
  String? get string => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BroadcastCopyWith<Broadcast> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BroadcastCopyWith<$Res> {
  factory $BroadcastCopyWith(Broadcast value, $Res Function(Broadcast) then) =
      _$BroadcastCopyWithImpl<$Res, Broadcast>;
  @useResult
  $Res call({String? day, String? time, String? timezone, String? string});
}

/// @nodoc
class _$BroadcastCopyWithImpl<$Res, $Val extends Broadcast>
    implements $BroadcastCopyWith<$Res> {
  _$BroadcastCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? day = freezed,
    Object? time = freezed,
    Object? timezone = freezed,
    Object? string = freezed,
  }) {
    return _then(_value.copyWith(
      day: freezed == day
          ? _value.day
          : day // ignore: cast_nullable_to_non_nullable
              as String?,
      time: freezed == time
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as String?,
      timezone: freezed == timezone
          ? _value.timezone
          : timezone // ignore: cast_nullable_to_non_nullable
              as String?,
      string: freezed == string
          ? _value.string
          : string // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BroadcastImplCopyWith<$Res>
    implements $BroadcastCopyWith<$Res> {
  factory _$$BroadcastImplCopyWith(
          _$BroadcastImpl value, $Res Function(_$BroadcastImpl) then) =
      __$$BroadcastImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? day, String? time, String? timezone, String? string});
}

/// @nodoc
class __$$BroadcastImplCopyWithImpl<$Res>
    extends _$BroadcastCopyWithImpl<$Res, _$BroadcastImpl>
    implements _$$BroadcastImplCopyWith<$Res> {
  __$$BroadcastImplCopyWithImpl(
      _$BroadcastImpl _value, $Res Function(_$BroadcastImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? day = freezed,
    Object? time = freezed,
    Object? timezone = freezed,
    Object? string = freezed,
  }) {
    return _then(_$BroadcastImpl(
      day: freezed == day
          ? _value.day
          : day // ignore: cast_nullable_to_non_nullable
              as String?,
      time: freezed == time
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as String?,
      timezone: freezed == timezone
          ? _value.timezone
          : timezone // ignore: cast_nullable_to_non_nullable
              as String?,
      string: freezed == string
          ? _value.string
          : string // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$BroadcastImpl implements _Broadcast {
  const _$BroadcastImpl({this.day, this.time, this.timezone, this.string});

  factory _$BroadcastImpl.fromJson(Map<String, dynamic> json) =>
      _$$BroadcastImplFromJson(json);

  @override
  final String? day;
  @override
  final String? time;
  @override
  final String? timezone;
  @override
  final String? string;

  @override
  String toString() {
    return 'Broadcast(day: $day, time: $time, timezone: $timezone, string: $string)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BroadcastImpl &&
            (identical(other.day, day) || other.day == day) &&
            (identical(other.time, time) || other.time == time) &&
            (identical(other.timezone, timezone) ||
                other.timezone == timezone) &&
            (identical(other.string, string) || other.string == string));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, day, time, timezone, string);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BroadcastImplCopyWith<_$BroadcastImpl> get copyWith =>
      __$$BroadcastImplCopyWithImpl<_$BroadcastImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$BroadcastImplToJson(
      this,
    );
  }
}

abstract class _Broadcast implements Broadcast {
  const factory _Broadcast(
      {final String? day,
      final String? time,
      final String? timezone,
      final String? string}) = _$BroadcastImpl;

  factory _Broadcast.fromJson(Map<String, dynamic> json) =
      _$BroadcastImpl.fromJson;

  @override
  String? get day;
  @override
  String? get time;
  @override
  String? get timezone;
  @override
  String? get string;
  @override
  @JsonKey(ignore: true)
  _$$BroadcastImplCopyWith<_$BroadcastImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Demographic _$DemographicFromJson(Map<String, dynamic> json) {
  return _Demographic.fromJson(json);
}

/// @nodoc
mixin _$Demographic {
  int? get malId => throw _privateConstructorUsedError;
  String? get type => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;
  String? get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DemographicCopyWith<Demographic> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DemographicCopyWith<$Res> {
  factory $DemographicCopyWith(
          Demographic value, $Res Function(Demographic) then) =
      _$DemographicCopyWithImpl<$Res, Demographic>;
  @useResult
  $Res call({int? malId, String? type, String? name, String? url});
}

/// @nodoc
class _$DemographicCopyWithImpl<$Res, $Val extends Demographic>
    implements $DemographicCopyWith<$Res> {
  _$DemographicCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? malId = freezed,
    Object? type = freezed,
    Object? name = freezed,
    Object? url = freezed,
  }) {
    return _then(_value.copyWith(
      malId: freezed == malId
          ? _value.malId
          : malId // ignore: cast_nullable_to_non_nullable
              as int?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DemographicImplCopyWith<$Res>
    implements $DemographicCopyWith<$Res> {
  factory _$$DemographicImplCopyWith(
          _$DemographicImpl value, $Res Function(_$DemographicImpl) then) =
      __$$DemographicImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? malId, String? type, String? name, String? url});
}

/// @nodoc
class __$$DemographicImplCopyWithImpl<$Res>
    extends _$DemographicCopyWithImpl<$Res, _$DemographicImpl>
    implements _$$DemographicImplCopyWith<$Res> {
  __$$DemographicImplCopyWithImpl(
      _$DemographicImpl _value, $Res Function(_$DemographicImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? malId = freezed,
    Object? type = freezed,
    Object? name = freezed,
    Object? url = freezed,
  }) {
    return _then(_$DemographicImpl(
      malId: freezed == malId
          ? _value.malId
          : malId // ignore: cast_nullable_to_non_nullable
              as int?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DemographicImpl implements _Demographic {
  const _$DemographicImpl({this.malId, this.type, this.name, this.url});

  factory _$DemographicImpl.fromJson(Map<String, dynamic> json) =>
      _$$DemographicImplFromJson(json);

  @override
  final int? malId;
  @override
  final String? type;
  @override
  final String? name;
  @override
  final String? url;

  @override
  String toString() {
    return 'Demographic(malId: $malId, type: $type, name: $name, url: $url)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DemographicImpl &&
            (identical(other.malId, malId) || other.malId == malId) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, malId, type, name, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DemographicImplCopyWith<_$DemographicImpl> get copyWith =>
      __$$DemographicImplCopyWithImpl<_$DemographicImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DemographicImplToJson(
      this,
    );
  }
}

abstract class _Demographic implements Demographic {
  const factory _Demographic(
      {final int? malId,
      final String? type,
      final String? name,
      final String? url}) = _$DemographicImpl;

  factory _Demographic.fromJson(Map<String, dynamic> json) =
      _$DemographicImpl.fromJson;

  @override
  int? get malId;
  @override
  String? get type;
  @override
  String? get name;
  @override
  String? get url;
  @override
  @JsonKey(ignore: true)
  _$$DemographicImplCopyWith<_$DemographicImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Image _$ImageFromJson(Map<String, dynamic> json) {
  return _Image.fromJson(json);
}

/// @nodoc
mixin _$Image {
  String? get imageUrl => throw _privateConstructorUsedError;
  String? get smallImageUrl => throw _privateConstructorUsedError;
  String? get largeImageUrl => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ImageCopyWith<Image> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImageCopyWith<$Res> {
  factory $ImageCopyWith(Image value, $Res Function(Image) then) =
      _$ImageCopyWithImpl<$Res, Image>;
  @useResult
  $Res call({String? imageUrl, String? smallImageUrl, String? largeImageUrl});
}

/// @nodoc
class _$ImageCopyWithImpl<$Res, $Val extends Image>
    implements $ImageCopyWith<$Res> {
  _$ImageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? imageUrl = freezed,
    Object? smallImageUrl = freezed,
    Object? largeImageUrl = freezed,
  }) {
    return _then(_value.copyWith(
      imageUrl: freezed == imageUrl
          ? _value.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      smallImageUrl: freezed == smallImageUrl
          ? _value.smallImageUrl
          : smallImageUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      largeImageUrl: freezed == largeImageUrl
          ? _value.largeImageUrl
          : largeImageUrl // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ImageImplCopyWith<$Res> implements $ImageCopyWith<$Res> {
  factory _$$ImageImplCopyWith(
          _$ImageImpl value, $Res Function(_$ImageImpl) then) =
      __$$ImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? imageUrl, String? smallImageUrl, String? largeImageUrl});
}

/// @nodoc
class __$$ImageImplCopyWithImpl<$Res>
    extends _$ImageCopyWithImpl<$Res, _$ImageImpl>
    implements _$$ImageImplCopyWith<$Res> {
  __$$ImageImplCopyWithImpl(
      _$ImageImpl _value, $Res Function(_$ImageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? imageUrl = freezed,
    Object? smallImageUrl = freezed,
    Object? largeImageUrl = freezed,
  }) {
    return _then(_$ImageImpl(
      imageUrl: freezed == imageUrl
          ? _value.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      smallImageUrl: freezed == smallImageUrl
          ? _value.smallImageUrl
          : smallImageUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      largeImageUrl: freezed == largeImageUrl
          ? _value.largeImageUrl
          : largeImageUrl // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ImageImpl implements _Image {
  const _$ImageImpl({this.imageUrl, this.smallImageUrl, this.largeImageUrl});

  factory _$ImageImpl.fromJson(Map<String, dynamic> json) =>
      _$$ImageImplFromJson(json);

  @override
  final String? imageUrl;
  @override
  final String? smallImageUrl;
  @override
  final String? largeImageUrl;

  @override
  String toString() {
    return 'Image(imageUrl: $imageUrl, smallImageUrl: $smallImageUrl, largeImageUrl: $largeImageUrl)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ImageImpl &&
            (identical(other.imageUrl, imageUrl) ||
                other.imageUrl == imageUrl) &&
            (identical(other.smallImageUrl, smallImageUrl) ||
                other.smallImageUrl == smallImageUrl) &&
            (identical(other.largeImageUrl, largeImageUrl) ||
                other.largeImageUrl == largeImageUrl));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, imageUrl, smallImageUrl, largeImageUrl);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ImageImplCopyWith<_$ImageImpl> get copyWith =>
      __$$ImageImplCopyWithImpl<_$ImageImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ImageImplToJson(
      this,
    );
  }
}

abstract class _Image implements Image {
  const factory _Image(
      {final String? imageUrl,
      final String? smallImageUrl,
      final String? largeImageUrl}) = _$ImageImpl;

  factory _Image.fromJson(Map<String, dynamic> json) = _$ImageImpl.fromJson;

  @override
  String? get imageUrl;
  @override
  String? get smallImageUrl;
  @override
  String? get largeImageUrl;
  @override
  @JsonKey(ignore: true)
  _$$ImageImplCopyWith<_$ImageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Relation _$RelationFromJson(Map<String, dynamic> json) {
  return _Relation.fromJson(json);
}

/// @nodoc
mixin _$Relation {
  String? get relation => throw _privateConstructorUsedError;
  List<Demographic>? get entry => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RelationCopyWith<Relation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RelationCopyWith<$Res> {
  factory $RelationCopyWith(Relation value, $Res Function(Relation) then) =
      _$RelationCopyWithImpl<$Res, Relation>;
  @useResult
  $Res call({String? relation, List<Demographic>? entry});
}

/// @nodoc
class _$RelationCopyWithImpl<$Res, $Val extends Relation>
    implements $RelationCopyWith<$Res> {
  _$RelationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? relation = freezed,
    Object? entry = freezed,
  }) {
    return _then(_value.copyWith(
      relation: freezed == relation
          ? _value.relation
          : relation // ignore: cast_nullable_to_non_nullable
              as String?,
      entry: freezed == entry
          ? _value.entry
          : entry // ignore: cast_nullable_to_non_nullable
              as List<Demographic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RelationImplCopyWith<$Res>
    implements $RelationCopyWith<$Res> {
  factory _$$RelationImplCopyWith(
          _$RelationImpl value, $Res Function(_$RelationImpl) then) =
      __$$RelationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? relation, List<Demographic>? entry});
}

/// @nodoc
class __$$RelationImplCopyWithImpl<$Res>
    extends _$RelationCopyWithImpl<$Res, _$RelationImpl>
    implements _$$RelationImplCopyWith<$Res> {
  __$$RelationImplCopyWithImpl(
      _$RelationImpl _value, $Res Function(_$RelationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? relation = freezed,
    Object? entry = freezed,
  }) {
    return _then(_$RelationImpl(
      relation: freezed == relation
          ? _value.relation
          : relation // ignore: cast_nullable_to_non_nullable
              as String?,
      entry: freezed == entry
          ? _value._entry
          : entry // ignore: cast_nullable_to_non_nullable
              as List<Demographic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RelationImpl implements _Relation {
  const _$RelationImpl({this.relation, final List<Demographic>? entry})
      : _entry = entry;

  factory _$RelationImpl.fromJson(Map<String, dynamic> json) =>
      _$$RelationImplFromJson(json);

  @override
  final String? relation;
  final List<Demographic>? _entry;
  @override
  List<Demographic>? get entry {
    final value = _entry;
    if (value == null) return null;
    if (_entry is EqualUnmodifiableListView) return _entry;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Relation(relation: $relation, entry: $entry)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RelationImpl &&
            (identical(other.relation, relation) ||
                other.relation == relation) &&
            const DeepCollectionEquality().equals(other._entry, _entry));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, relation, const DeepCollectionEquality().hash(_entry));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RelationImplCopyWith<_$RelationImpl> get copyWith =>
      __$$RelationImplCopyWithImpl<_$RelationImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RelationImplToJson(
      this,
    );
  }
}

abstract class _Relation implements Relation {
  const factory _Relation(
      {final String? relation,
      final List<Demographic>? entry}) = _$RelationImpl;

  factory _Relation.fromJson(Map<String, dynamic> json) =
      _$RelationImpl.fromJson;

  @override
  String? get relation;
  @override
  List<Demographic>? get entry;
  @override
  @JsonKey(ignore: true)
  _$$RelationImplCopyWith<_$RelationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Theme _$ThemeFromJson(Map<String, dynamic> json) {
  return _Theme.fromJson(json);
}

/// @nodoc
mixin _$Theme {
  List<String>? get openings => throw _privateConstructorUsedError;
  List<String>? get endings => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ThemeCopyWith<Theme> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ThemeCopyWith<$Res> {
  factory $ThemeCopyWith(Theme value, $Res Function(Theme) then) =
      _$ThemeCopyWithImpl<$Res, Theme>;
  @useResult
  $Res call({List<String>? openings, List<String>? endings});
}

/// @nodoc
class _$ThemeCopyWithImpl<$Res, $Val extends Theme>
    implements $ThemeCopyWith<$Res> {
  _$ThemeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? openings = freezed,
    Object? endings = freezed,
  }) {
    return _then(_value.copyWith(
      openings: freezed == openings
          ? _value.openings
          : openings // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      endings: freezed == endings
          ? _value.endings
          : endings // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ThemeImplCopyWith<$Res> implements $ThemeCopyWith<$Res> {
  factory _$$ThemeImplCopyWith(
          _$ThemeImpl value, $Res Function(_$ThemeImpl) then) =
      __$$ThemeImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<String>? openings, List<String>? endings});
}

/// @nodoc
class __$$ThemeImplCopyWithImpl<$Res>
    extends _$ThemeCopyWithImpl<$Res, _$ThemeImpl>
    implements _$$ThemeImplCopyWith<$Res> {
  __$$ThemeImplCopyWithImpl(
      _$ThemeImpl _value, $Res Function(_$ThemeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? openings = freezed,
    Object? endings = freezed,
  }) {
    return _then(_$ThemeImpl(
      openings: freezed == openings
          ? _value._openings
          : openings // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      endings: freezed == endings
          ? _value._endings
          : endings // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ThemeImpl implements _Theme {
  const _$ThemeImpl({final List<String>? openings, final List<String>? endings})
      : _openings = openings,
        _endings = endings;

  factory _$ThemeImpl.fromJson(Map<String, dynamic> json) =>
      _$$ThemeImplFromJson(json);

  final List<String>? _openings;
  @override
  List<String>? get openings {
    final value = _openings;
    if (value == null) return null;
    if (_openings is EqualUnmodifiableListView) return _openings;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _endings;
  @override
  List<String>? get endings {
    final value = _endings;
    if (value == null) return null;
    if (_endings is EqualUnmodifiableListView) return _endings;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Theme(openings: $openings, endings: $endings)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ThemeImpl &&
            const DeepCollectionEquality().equals(other._openings, _openings) &&
            const DeepCollectionEquality().equals(other._endings, _endings));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_openings),
      const DeepCollectionEquality().hash(_endings));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ThemeImplCopyWith<_$ThemeImpl> get copyWith =>
      __$$ThemeImplCopyWithImpl<_$ThemeImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ThemeImplToJson(
      this,
    );
  }
}

abstract class _Theme implements Theme {
  const factory _Theme(
      {final List<String>? openings,
      final List<String>? endings}) = _$ThemeImpl;

  factory _Theme.fromJson(Map<String, dynamic> json) = _$ThemeImpl.fromJson;

  @override
  List<String>? get openings;
  @override
  List<String>? get endings;
  @override
  @JsonKey(ignore: true)
  _$$ThemeImplCopyWith<_$ThemeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Title _$TitleFromJson(Map<String, dynamic> json) {
  return _Title.fromJson(json);
}

/// @nodoc
mixin _$Title {
  String? get type => throw _privateConstructorUsedError;
  String? get title => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TitleCopyWith<Title> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TitleCopyWith<$Res> {
  factory $TitleCopyWith(Title value, $Res Function(Title) then) =
      _$TitleCopyWithImpl<$Res, Title>;
  @useResult
  $Res call({String? type, String? title});
}

/// @nodoc
class _$TitleCopyWithImpl<$Res, $Val extends Title>
    implements $TitleCopyWith<$Res> {
  _$TitleCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = freezed,
    Object? title = freezed,
  }) {
    return _then(_value.copyWith(
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TitleImplCopyWith<$Res> implements $TitleCopyWith<$Res> {
  factory _$$TitleImplCopyWith(
          _$TitleImpl value, $Res Function(_$TitleImpl) then) =
      __$$TitleImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? type, String? title});
}

/// @nodoc
class __$$TitleImplCopyWithImpl<$Res>
    extends _$TitleCopyWithImpl<$Res, _$TitleImpl>
    implements _$$TitleImplCopyWith<$Res> {
  __$$TitleImplCopyWithImpl(
      _$TitleImpl _value, $Res Function(_$TitleImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = freezed,
    Object? title = freezed,
  }) {
    return _then(_$TitleImpl(
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TitleImpl implements _Title {
  const _$TitleImpl({this.type, this.title});

  factory _$TitleImpl.fromJson(Map<String, dynamic> json) =>
      _$$TitleImplFromJson(json);

  @override
  final String? type;
  @override
  final String? title;

  @override
  String toString() {
    return 'Title(type: $type, title: $title)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TitleImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.title, title) || other.title == title));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, title);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TitleImplCopyWith<_$TitleImpl> get copyWith =>
      __$$TitleImplCopyWithImpl<_$TitleImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TitleImplToJson(
      this,
    );
  }
}

abstract class _Title implements Title {
  const factory _Title({final String? type, final String? title}) = _$TitleImpl;

  factory _Title.fromJson(Map<String, dynamic> json) = _$TitleImpl.fromJson;

  @override
  String? get type;
  @override
  String? get title;
  @override
  @JsonKey(ignore: true)
  _$$TitleImplCopyWith<_$TitleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Trailer _$TrailerFromJson(Map<String, dynamic> json) {
  return _Trailer.fromJson(json);
}

/// @nodoc
mixin _$Trailer {
  String? get youtubeId => throw _privateConstructorUsedError;
  String? get url => throw _privateConstructorUsedError;
  String? get embedUrl => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TrailerCopyWith<Trailer> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TrailerCopyWith<$Res> {
  factory $TrailerCopyWith(Trailer value, $Res Function(Trailer) then) =
      _$TrailerCopyWithImpl<$Res, Trailer>;
  @useResult
  $Res call({String? youtubeId, String? url, String? embedUrl});
}

/// @nodoc
class _$TrailerCopyWithImpl<$Res, $Val extends Trailer>
    implements $TrailerCopyWith<$Res> {
  _$TrailerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? youtubeId = freezed,
    Object? url = freezed,
    Object? embedUrl = freezed,
  }) {
    return _then(_value.copyWith(
      youtubeId: freezed == youtubeId
          ? _value.youtubeId
          : youtubeId // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      embedUrl: freezed == embedUrl
          ? _value.embedUrl
          : embedUrl // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TrailerImplCopyWith<$Res> implements $TrailerCopyWith<$Res> {
  factory _$$TrailerImplCopyWith(
          _$TrailerImpl value, $Res Function(_$TrailerImpl) then) =
      __$$TrailerImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? youtubeId, String? url, String? embedUrl});
}

/// @nodoc
class __$$TrailerImplCopyWithImpl<$Res>
    extends _$TrailerCopyWithImpl<$Res, _$TrailerImpl>
    implements _$$TrailerImplCopyWith<$Res> {
  __$$TrailerImplCopyWithImpl(
      _$TrailerImpl _value, $Res Function(_$TrailerImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? youtubeId = freezed,
    Object? url = freezed,
    Object? embedUrl = freezed,
  }) {
    return _then(_$TrailerImpl(
      youtubeId: freezed == youtubeId
          ? _value.youtubeId
          : youtubeId // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      embedUrl: freezed == embedUrl
          ? _value.embedUrl
          : embedUrl // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TrailerImpl implements _Trailer {
  const _$TrailerImpl({this.youtubeId, this.url, this.embedUrl});

  factory _$TrailerImpl.fromJson(Map<String, dynamic> json) =>
      _$$TrailerImplFromJson(json);

  @override
  final String? youtubeId;
  @override
  final String? url;
  @override
  final String? embedUrl;

  @override
  String toString() {
    return 'Trailer(youtubeId: $youtubeId, url: $url, embedUrl: $embedUrl)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TrailerImpl &&
            (identical(other.youtubeId, youtubeId) ||
                other.youtubeId == youtubeId) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.embedUrl, embedUrl) ||
                other.embedUrl == embedUrl));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, youtubeId, url, embedUrl);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TrailerImplCopyWith<_$TrailerImpl> get copyWith =>
      __$$TrailerImplCopyWithImpl<_$TrailerImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TrailerImplToJson(
      this,
    );
  }
}

abstract class _Trailer implements Trailer {
  const factory _Trailer(
      {final String? youtubeId,
      final String? url,
      final String? embedUrl}) = _$TrailerImpl;

  factory _Trailer.fromJson(Map<String, dynamic> json) = _$TrailerImpl.fromJson;

  @override
  String? get youtubeId;
  @override
  String? get url;
  @override
  String? get embedUrl;
  @override
  @JsonKey(ignore: true)
  _$$TrailerImplCopyWith<_$TrailerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
